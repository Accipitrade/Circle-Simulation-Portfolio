import './App.css';
import Circle from './Circle.js';
import { CheckCC, MoveCC, GetCCVel, CheckCW, MoveCW, GetCWVel, GetMagnitude, FindCompositeVel, CheckCWTouch } from './CollisionDetection.js';
import React, { useEffect, useState, useRef, useCallback } from 'react';
import FrameQueue from './FrameQueue.js';

function App() {

  const screenSize = useRef({ width: window.innerWidth, height: window.innerHeight });

  const baseCircles = [
    {
      id: 0,
      radius: 47,
      position: { x: screenSize.current.width * 0.2, y: screenSize.current.height * 0.3 },
      velocity: { x: 50, y: 12 },
    },
    {
      id: 1,
      radius: 25,
      position: { x: screenSize.current.width * 0.8, y: screenSize.current.height * 0.3 },
      velocity: { x: -500.5, y: 20 },
    },
    {
      id: 2,
      radius: 30,
      position: { x: screenSize.current.width * 0.6, y: screenSize.current.height * 0.6 },
      velocity: { x: -10.5, y: -14 },
    },
    {
      id: 3,
      radius: 36,
      position: { x: screenSize.current.width * 0.1, y: screenSize.current.height * 0.5 },
      velocity: { x: 0, y: -30 },
    },
    {
      id: 4,
      radius: 58,
      position: { x: screenSize.current.width * 0.3, y: screenSize.current.height * 0.4 },
      velocity: { x: 40, y: 12 },
    }
  ];

  const [isPaused, setIsPaused] = useState(false);

  const mousePosition = useRef({ x: 0, y: 0 });
  const draggedCircle = useRef('');
  //const [draggedCircle, setDraggedCircle] = useState('');
  const isDragging = useRef(false);
  const mouseFrameData = useRef(new FrameQueue(7));
  const compositeVelocity = useRef({ x: 0, y: 0 }); // use this to store velocity generated by frame data, use it inside of animation to apply new velocity
  const mouseClickedUp = useRef(false); // use this to raise a flag for one frame to apply an updated velocity from the above variable.
  const mouseClickTime = useRef(0);
  const mouseClickUpID = useRef(0); //using this to store ID of circle that was click and dragged but after they let go (to assign velocity)

  //Add a frame's worth of position data for the mouse along with a timestamp to the FrameQueue.
  const PushFrameData = () => {
    const currentTimestamp = Date.now();

    if (mouseFrameData.current.length === 0) {
      mouseFrameData.current.push([{ x: mousePosition.current.x, y: mousePosition.current.y }, currentTimestamp]);
    }
    // If it's not empty, check the timestamp of the last entry
    else {
      //let testArr = mouseFrameData.current.getframeQueue();
      if (mouseFrameData.current.get(mouseFrameData.current.length - 1)[1] !== currentTimestamp) {
        mouseFrameData.current.push([{ x: mousePosition.current.x, y: mousePosition.current.y }, currentTimestamp]);
      }
    }


  }

  const updateMousePosition = (ev) => {
    let x, y;
    if (ev.type === 'touchmove' || ev.type === 'touchstart') {
        x = ev.touches[0].clientX;
        y = ev.touches[0].clientY;
    } else {
        x = ev.clientX;
        y = ev.clientY;
    }
    mousePosition.current = { x: x, y: y };
};

  useEffect(() => {
    const updateScreenSize = () => {
      screenSize.current = {
        width: window.innerWidth,
        height: window.innerHeight,
      };
    };

    

    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
          animationFrameID.current = requestAnimationFrame(animate);
      } else {
          cancelAnimationFrame(animationFrameID.current);
      }
  };



    // Initial update
    updateScreenSize();

    // To handle when the user tabs out
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // Event listener to update on screen resize
    window.addEventListener('resize', updateScreenSize);
    // Mouse Position/Mobile Tap Position event listeners
    window.addEventListener('mousemove', updateMousePosition);
    window.addEventListener('mousedown', OnMouseDown);
    window.addEventListener('mouseup', OnMouseUp);
    window.addEventListener('touchstart', OnMouseDown);
    window.addEventListener('touchmove', updateMousePosition);
    window.addEventListener('touchcancel', OnMouseUp);
    window.addEventListener('touchend', OnMouseUp);

    // Clean up the event listeners on unmount
    return () => {
      window.removeEventListener('resize', updateScreenSize);
      window.removeEventListener('mousemove', updateMousePosition);
      window.removeEventListener('mousedown', OnMouseDown);
      window.removeEventListener('mouseup', OnMouseUp);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('touchstart', OnMouseDown);
    window.removeEventListener('touchmove', updateMousePosition);
    window.removeEventListener('touchcancel', OnMouseUp);
    window.removeEventListener('touchend', OnMouseUp);
    };
  }, []);


  useEffect(() => {
    if(isPaused){
      cancelAnimationFrame(animate);
    } else {
      requestAnimationFrame(animate);
    }
  }, [isPaused]);

  const [circles, setCircles] = useState(baseCircles);

  const animationFrameID = useRef();

  const timeStep = 0.025;

  const animate = useCallback(() => {

    if (isDragging.current) {
      PushFrameData();
      console.log("dragging circle: " + draggedCircle.current);
    }

    setCircles((prevCircles) => {
      let newCircles = [...prevCircles];

      // Calculate the maximum velocity magnitude among all circles
      let maxVelocityMagnitude = 0;
      prevCircles.forEach((circle) => {
        const velocityMagnitude = GetMagnitude(circle.velocity);
        if (velocityMagnitude > maxVelocityMagnitude) {
          maxVelocityMagnitude = velocityMagnitude;
        }
      });

      // Calculate the number of steps needed for this frame
      const steps = Math.ceil(maxVelocityMagnitude * timeStep);

      let collisionDetected = false;
      let dragCollisionID = 0; //this variable holds the ID of the circle that the dragged circle collided with
      let dragCollisionDetected = false;

      for (let step = 0; step < steps; step++) {
        // Update positions for each time step
        newCircles = newCircles.map((circle) => {
          let newPosition = {};
          let newVelocity = {
              x: circle.velocity.x * 0.98,
              y: circle.velocity.y * 0.98,
            };

            //if the user was dragging a circle and let go, transfer the mouse's velocity to the circle
            //console.log(mouseClickUpID.current);
          if(mouseClickedUp.current && circle.id === mouseClickUpID.current){
            console.log("reached");
              newVelocity = {
                x: compositeVelocity.current.x * 98,
                y: compositeVelocity.current.y * 98,
              };
              mouseClickedUp.current = false;
              mouseClickUpID.current = '';
          }
          //if the user is dragging a circle and the circle's ID is the same as the dragged circle
          if (isDragging.current && circle.id === draggedCircle.current) {
            
            //assign the mouse's position (with an offset) to the circle
            newPosition = { //no offset, because it causes some funky behavior
              x: mousePosition.current.x,
              y: mousePosition.current.y,
            };
          } else {
            //since the circle isn't being dragged, then do standard position/velocity calculation
            newPosition = {
              x: circle.position.x + newVelocity.x * timeStep,
              y: circle.position.y + newVelocity.y * timeStep,
            };
          }

          // Check and resolve Circle-Wall collisions
          if (CheckCW(newPosition, circle.radius, screenSize.current.width, screenSize.current.height)) {
            //console.log("colliding with wall!");
            const [newPos, wallNormal] = MoveCW(newPosition, circle.radius, screenSize.current.width, screenSize.current.height);
            newPosition.x = newPos.x;
            newPosition.y = newPos.y;
            newVelocity = GetCWVel(newPosition, newVelocity, wallNormal);
          }

          return {
            ...circle,
            position: newPosition,
            velocity: newVelocity,
          };
        });

       
        // Check and resolve collisions after each time step
        for (let i = 0; i < newCircles.length; i++) {
          for (let j = i + 1; j < newCircles.length; j++) {
            //if not dragging and i or j are not equal to the dragged circle
            //if (!(isDragging.current && (i === draggedCircle.current || j === draggedCircle.current))) {
            if (
              //check collisions for two circles
              CheckCC(
                newCircles[i].position,
                newCircles[i].radius,
                newCircles[j].position,
                newCircles[j].radius
              )
            ) {
              //if they collided, move them so they're not
              const collisionPositions = MoveCC(
                newCircles[i].position,
                newCircles[i].radius,
                newCircles[j].position,
                newCircles[j].radius
              );

              let collisionVelocities = [{ x: 0, y: 0 }, { x: 0, y: 0 }];
              if (isDragging.current) {
                if (i === draggedCircle.current) {
                  collisionVelocities = [{ x: 0, y: 0 }, FindCompositeVel(mouseFrameData.current.getframeQueue())];
                  collisionVelocities[1].x *= 70;
                  collisionVelocities[1].y *= 70;
                  dragCollisionID = j;
                  dragCollisionDetected = true;
                  //console.log(collisionVelocities[1].x + " " + collisionVelocities[1].y);
                } else if (j === draggedCircle.current) {
                  collisionVelocities = [FindCompositeVel(mouseFrameData.current.getframeQueue()), { x: 0, y: 0 }];
                  collisionVelocities[0].x *= 70;
                  collisionVelocities[0].y *= 70;
                  dragCollisionID = i;
                  dragCollisionDetected = true;
                  //console.log(collisionVelocities[0].x + " " + collisionVelocities[0].y);
                }
              } else {
                collisionVelocities = GetCCVel(
                  newCircles[i].position,
                  newCircles[i].velocity,
                  newCircles[j].position,
                  newCircles[j].velocity
                );
              }

              if (isDragging.current) {
                if (i === draggedCircle.current) {
                  newCircles[j].position = collisionPositions[1];
                  newCircles[j].velocity = collisionVelocities[1];
                  //set j's position and velocity
                } else if (j === draggedCircle.current) {
                  newCircles[i].position = collisionPositions[0];
                  newCircles[i].velocity = collisionVelocities[0];
                  //set i's position and velocity
                }
              } else {
                //set both position and velocity
                newCircles[i].position = collisionPositions[0];
                newCircles[j].position = collisionPositions[1];
                newCircles[i].velocity = collisionVelocities[0];
                newCircles[j].velocity = collisionVelocities[1];
              }

            }
          }
        }

        // Check and resolve collisions a second time, ignoring the dragged circle collisions. 
        //this resolves multi-body collisions.

        do {
          //console.log("recursion");
          collisionDetected = false;
          for (let i = 0; i < newCircles.length; i++) {
            for (let j = i + 1; j < newCircles.length; j++) {
              //if not dragging and i or j are not equal to the dragged circle
              //if (!(isDragging.current && (i === draggedCircle.current || j === draggedCircle.current))) {
              if (isDragging.current && i === draggedCircle.current || j === draggedCircle.current) {
                continue;
              }
  
              if (
                //check collisions for two circles
                CheckCC(
                  newCircles[i].position,
                  newCircles[i].radius,
                  newCircles[j].position,
                  newCircles[j].radius
                )
              ) {
                collisionDetected = true;
                //if they collided, move them so they're not
                const collisionPositions = MoveCC(
                  newCircles[i].position,
                  newCircles[i].radius,
                  newCircles[j].position,
                  newCircles[j].radius
                );
  
                let collisionVelocities = [{ x: 0, y: 0 }, { x: 0, y: 0 }];
  
                collisionVelocities = GetCCVel(
                  newCircles[i].position,
                  newCircles[i].velocity,
                  newCircles[j].position,
                  newCircles[j].velocity
                );
  
                //set both position and velocity
                newCircles[i].position = collisionPositions[0];
                newCircles[j].position = collisionPositions[1];
                newCircles[i].velocity = collisionVelocities[0];
                newCircles[j].velocity = collisionVelocities[1];
  
              } 
            }
          }
        } while (collisionDetected);
        
        
        //checking circle-wall collisions a final time prevents circles from being pushed out of bounds from other collisions
        newCircles.forEach((circle) => {
          // Check and resolve Circle-Wall collisions
          if (CheckCW(circle.position, circle.radius, screenSize.current.width, screenSize.current.height)) {
            const [newPos, wallNormal] = MoveCW(circle.position, circle.radius, screenSize.current.width, screenSize.current.height);
            circle.position.x = newPos.x;
            circle.position.y = newPos.y;
            circle.velocity = GetCWVel(circle.position, circle.velocity, wallNormal);
          }
        });

        //compare collided circle and dragged circle to make sure they don't overlap when the collided circle is in the corner
        if(dragCollisionDetected){
          if(isDragging.current){
            let newPositions;
            if(CheckCWTouch(newCircles[dragCollisionID].position, newCircles[dragCollisionID].radius, screenSize.current.width, screenSize.current.height)){
              //console.log("attempting to separate circle in corner.");
              if(CheckCC(newCircles[draggedCircle.current].position, newCircles[draggedCircle.current].radius, newCircles[dragCollisionID].position, newCircles[dragCollisionID].radius)){
                newPositions = MoveCC(newCircles[draggedCircle.current].position, newCircles[draggedCircle.current].radius, newCircles[dragCollisionID].position, newCircles[dragCollisionID].radius);
                newCircles[draggedCircle.current].position = newPositions[0];
                if(CheckCW(newCircles[draggedCircle.current].position, newCircles[draggedCircle.current].radius, screenSize.current.width, screenSize.current.height)){
                  newCircles[draggedCircle.current].position = MoveCW(newCircles[draggedCircle.current].position, newCircles[draggedCircle.current].radius, screenSize.current.width, screenSize.current.height);
                }
              }
            }
          }
        }
        
      }

      return newCircles;
    });
    animationFrameID.current = requestAnimationFrame(animate);
  }, []);


  useEffect(() => {

    setCircles(baseCircles);

    const startAnimation = () => {
      // Pause the animation for 5 seconds using setTimeout
      setTimeout(() => {
        animationFrameID.current = requestAnimationFrame(animate);
      }, 1000);
    };

    // If document has already been loaded, start the animation
    if (document.readyState === 'complete') {
      startAnimation();
    } else {
      // If not, wait for the 'load' event before starting
      window.addEventListener('load', startAnimation);
    }

    return () => {
      window.removeEventListener('load', startAnimation);
    };
  }, []);

  //used for circle interactions
  const OnMouseClick = (id) => {
    draggedCircle.current = id; //use the flag to move the circle to this position with an offset and ignore velocity, since it's being dragged
    isDragging.current = true; //boolean flag gets set to true here
    PushFrameData();
  }

  //general purpose mouse stuff
  const OnMouseDown = (ev) => {
    updateMousePosition(ev);
    if (ev.type === 'touchstart') {
      PushFrameData();
      //ev.preventDefault();
    }
    mouseClickTime.current = Date.now();
  }

  /*
   const OnMouseUp = () => {

    if(Date.now() - mouseClickTime.current <= 200){
      //console.log("clicked!")
    } else {
      compositeVelocity.current = FindCompositeVel(mouseFrameData.current.getframeQueue());
      //mouseClickedUp.current = true;
      mouseClickedUp.current = true;
      mouseClickUpID.current = draggedCircle.current;
    }
    //compare date.now() to variable with current time from OnMouseDown.
    //if it is less than 1 second, the user clicked. Any longer and they are dragging. 

    //if clicking:
    //do framer motion window animate thing. 


    //if dragging:
    //calculate FindCompositeVel here
    //assign FindCompositeVel to ref variable (?) that applies velocity to dragged circle with boolean flag in animate
    //can also lower the flag in animate as well. 
    
    isDragging.current = false;
    draggedCircle.current = '';
  }
*/
  const OnMouseUp = () => {
    isDragging.current = false;
    if(Date.now() - mouseClickTime.current <= 200){
      // It was a quick click
      draggedCircle.current = '';
    } else {
      // It was a drag
      compositeVelocity.current = FindCompositeVel(mouseFrameData.current.getframeQueue());
      mouseClickedUp.current = true;
      mouseClickUpID.current = draggedCircle.current;
      draggedCircle.current = '';
    }
}


  return (
    <div className='app-container'>
      <div className="center-container">
        <h1 style={{userSelect: 'none'}}>GO</h1>
        <h1 style={{userSelect: 'none'}}>WILD!!!!</h1>
      </div>
      {circles.map(circle => (
        <Circle className={`circle${circle.id}`}
          key={circle.id}
          id={circle.id}
          radius={circle.radius}
          pos={circle.position}
          onClick={OnMouseClick}
        />
      ))}
    </div>
  );
}

export default App;
